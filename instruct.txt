// ========================================
// PORTER TRANSACTION DATA AUTOMATION
// ========================================

// 1. BROWSER EXTENSION (manifest.json)
const extensionManifest = {
  "manifest_version": 3,
  "name": "Porter Transaction Scraper",
  "version": "1.0",
  "description": "Automated transaction data collection for Porter PFE dashboard",
  "permissions": [
    "activeTab",
    "storage",
    "alarms"
  ],
  "host_permissions": [
    "https://pfe.porter.in/*"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [{
    "matches": ["https://pfe.porter.in/dashboard/payments*"],
    "js": ["content.js"]
  }],
  "action": {
    "default_popup": "popup.html"
  }
};

// 2. CONTENT SCRIPT (content.js) - Runs on Porter pages
class PorterDataExtractor {
  constructor() {
    this.currentDate = this.getCurrentDateString();
    this.dataEndpoint = 'YOUR_GITHUB_WEBHOOK_URL'; // We'll set this up
  }

  getCurrentDateString() {
    const today = new Date();
    const day = String(today.getDate()).padStart(2, '0');
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const year = String(today.getFullYear()).slice(-2);
    return `${day}/${month}/${year}`;
  }

  extractTransactionData() {
    const transactions = [];
    
    // Wait for data to load
    const transactionRows = document.querySelectorAll('tr.table-row');
    
    if (transactionRows.length === 0) {
      console.log('No transaction rows found - page may still be loading');
      return null;
    }

    transactionRows.forEach((row, index) => {
      try {
        const cells = row.querySelectorAll('td');
        if (cells.length < 4) return;

        // Extract date
        const dateCell = cells[1];
        const dateText = dateCell?.textContent?.trim();
        const dateMatch = dateText?.match(/(\d{2}\/\d{2}\/\d{2})/);
        const timeMatch = dateText?.match(/(\d{1,2}:\d{2}\s*[AP]M)/i);

        if (!dateMatch) return;

        const transactionDate = dateMatch[1];
        
        // Only process today's transactions
        if (transactionDate === this.currentDate) {
          const transactionTime = timeMatch ? timeMatch[1] : 'Time not found';
          
          // Extract user
          const userCell = cells[2];
          const user = userCell?.textContent?.trim() || 'Unknown User';
          
          // Extract amount
          const amountCell = cells[3];
          const amountDiv = amountCell?.querySelector('#amount');
          const amountText = amountDiv?.textContent?.trim() || 'Amount not found';
          
          // Determine transaction type
          const isCredit = amountDiv?.classList.contains('status-green') || amountText.includes('+');
          const transactionType = isCredit ? 'Credit' : 'Debit';
          
          // Clean amount
          const cleanAmount = amountText.replace(/[â‚¹,+\s]/g, '');

          transactions.push({
            extractedAt: new Date().toISOString(),
            date: transactionDate,
            time: transactionTime,
            user: user,
            amount: cleanAmount,
            amountFormatted: amountText,
            type: transactionType,
            rowIndex: index + 1
          });
        }
      } catch (error) {
        console.error(`Error processing row ${index + 1}:`, error);
      }
    });

    return transactions;
  }

  async sendDataToGitHub(transactions) {
    if (!transactions || transactions.length === 0) {
      console.log('No transactions to send');
      return;
    }

    const payload = {
      timestamp: new Date().toISOString(),
      date: this.currentDate,
      transactionCount: transactions.length,
      transactions: transactions,
      summary: this.calculateSummary(transactions)
    };

    try {
      // Send to GitHub via webhook (we'll set this up)
      const response = await fetch(this.dataEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
      });

      if (response.ok) {
        console.log('Data sent successfully to GitHub');
        // Store success status
        chrome.storage.local.set({
          lastSync: new Date().toISOString(),
          lastSyncStatus: 'success',
          lastDataCount: transactions.length
        });
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      console.error('Failed to send data:', error);
      chrome.storage.local.set({
        lastSync: new Date().toISOString(),
        lastSyncStatus: 'failed',
        error: error.message
      });
    }
  }

  calculateSummary(transactions) {
    let totalCredit = 0;
    let totalDebit = 0;
    let creditCount = 0;
    let debitCount = 0;

    transactions.forEach(transaction => {
      const amount = parseFloat(transaction.amount.replace(/,/g, ''));
      if (transaction.type === 'Credit') {
        totalCredit += amount;
        creditCount++;
      } else {
        totalDebit += amount;
        debitCount++;
      }
    });

    return {
      totalTransactions: transactions.length,
      creditTransactions: creditCount,
      debitTransactions: debitCount,
      totalCreditAmount: totalCredit,
      totalDebitAmount: totalDebit,
      netAmount: totalCredit - totalDebit
    };
  }

  async runExtraction() {
    console.log('Starting Porter data extraction for date:', this.currentDate);
    
    // Wait for page to load completely
    if (document.readyState !== 'complete') {
      await new Promise(resolve => {
        window.addEventListener('load', resolve);
      });
    }

    // Additional wait for dynamic content
    await new Promise(resolve => setTimeout(resolve, 3000));

    const transactions = this.extractTransactionData();
    
    if (transactions && transactions.length > 0) {
      console.log(`Found ${transactions.length} transactions for ${this.currentDate}`);
      await this.sendDataToGitHub(transactions);
    } else {
      console.log(`No transactions found for ${this.currentDate}`);
      // Still send empty data to track the attempt
      await this.sendDataToGitHub([]);
    }
  }
}

// 3. BACKGROUND SCRIPT (background.js) - Handles scheduling
class PorterScheduler {
  constructor() {
    this.setupAlarms();
  }

  setupAlarms() {
    // Create alarm for 11:00 PM IST daily
    chrome.alarms.create('porterDataSync', {
      when: this.getNext11PM(),
      periodInMinutes: 24 * 60 // 24 hours
    });

    // Listen for alarm
    chrome.alarms.onAlarm.addListener((alarm) => {
      if (alarm.name === 'porterDataSync') {
        this.triggerDataExtraction();
      }
    });
  }

  getNext11PM() {
    const now = new Date();
    const next11PM = new Date();
    next11PM.setHours(23, 0, 0, 0); // 11:00 PM
    
    // If it's already past 11 PM today, set for tomorrow
    if (now.getTime() > next11PM.getTime()) {
      next11PM.setDate(next11PM.getDate() + 1);
    }
    
    return next11PM.getTime();
  }

  async triggerDataExtraction() {
    try {
      // Check if Porter tab is open
      const tabs = await chrome.tabs.query({
        url: 'https://pfe.porter.in/dashboard/payments*'
      });

      if (tabs.length > 0) {
        // Execute extraction on existing tab
        chrome.tabs.sendMessage(tabs[0].id, { action: 'extractData' });
      } else {
        // Create notification for user to open Porter
        chrome.notifications.create({
          type: 'basic',
          iconUrl: 'icon.png',
          title: 'Porter Data Sync',
          message: 'Please open Porter dashboard to sync today\'s transaction data'
        });
      }
    } catch (error) {
      console.error('Failed to trigger data extraction:', error);
    }
  }
}

// 4. GITHUB ACTIONS WORKFLOW (.github/workflows/porter-data.yml)
const githubWorkflow = `
name: Porter Transaction Data Processor

on:
  repository_dispatch:
    types: [porter-data]
  workflow_dispatch:

jobs:
  process-porter-data:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Create data directory
      run: mkdir -p data/porter-transactions
      
    - name: Process transaction data
      run: |
        echo '${{ github.event.client_payload.data }}' > data/porter-transactions/\$(date +%Y-%m-%d).json
        
    - name: Commit data
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "Porter Data Bot"
        git add data/porter-transactions/
        git commit -m "Add Porter transaction data for \$(date +%Y-%m-%d)" || exit 0
        git push
`;

// 5. WEBHOOK HANDLER (for GitHub repository dispatch)
class GitHubWebhook {
  constructor(repoOwner, repoName, token) {
    this.repoOwner = repoOwner;
    this.repoName = repoName;
    this.token = token;
  }

  async sendToGitHub(data) {
    const url = `https://api.github.com/repos/${this.repoOwner}/${this.repoName}/dispatches`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json',
        'X-GitHub-Api-Version': '2022-11-28'
      },
      body: JSON.stringify({
        event_type: 'porter-data',
        client_payload: {
          data: data,
          timestamp: new Date().toISOString()
        }
      })
    });

    return response.ok;
  }
}

// Initialize when content script loads
if (typeof window !== 'undefined' && window.location.hostname === 'pfe.porter.in') {
  const extractor = new PorterDataExtractor();
  
  // Listen for messages from background script
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'extractData') {
      extractor.runExtraction();
    }
  });

  // Auto-run if it's close to 11 PM
  const now = new Date();
  if (now.getHours() === 23 && now.getMinutes() >= 0) {
    extractor.runExtraction();
  }
}

// USAGE INSTRUCTIONS:
/*
1. Create browser extension with these files
2. Set up GitHub repository with webhook workflow
3. Generate GitHub Personal Access Token
4. Configure extension with your repo details
5. Install extension and keep Porter tab open around 11 PM

SECURITY CONSIDERATIONS:
- Store GitHub token securely (use GitHub Secrets)
- Only runs on authenticated Porter pages
- No sensitive data stored in extension
- Data transmitted over HTTPS only

LIMITATIONS:
- Requires user to be logged into Porter
- Browser must be open at 11 PM (or manual trigger)
- Depends on Porter's HTML structure remaining stable
*/